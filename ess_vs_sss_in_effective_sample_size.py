# %% imports
import dill
import functools as ft
import matplotlib.pyplot as plt
import numpy as np
import sys
import time

np.random.seed(1000)
# %% functions
def pi(x):
    """Calculate value of the density at the point x."""
    norm_x = np.linalg.norm(x)
    return np.exp(-norm_x - 0.5 * norm_x**2)

def pi2(x, y):
    """Basically pi(x) / pi(y)."""
    norm_x = np.linalg.norm(x)
    norm_y = np.linalg.norm(y)
    return np.exp(-norm_x + norm_y + 0.5*(-norm_x**2  + norm_y**2))

def random_MH(x0=[0], steps=10):
    """
    Perform the Metropolis-Hasting algorithm w.r.t. to the density pi
    given number of steps starting from x0.
    """
    d = len(x0)
    for i in range(steps):
        x1 = x0 + np.random.normal(scale=0.04, size=d)
        x0 = x1 if np.random.uniform() < pi2(x1, x0) else x0
    return x0

def runiform_ball(d, R=1):
    """
    Sample efficiently from a uniform distribution on a d-dimensional ball
    of radius R.
    """
    if R < 0: sys.exit("ERROR in runiform_ball: R must be nonnegative")
    x = np.random.normal(size = d)
    u = np.random.uniform()
    return R * u**(1 / d) * x / np.linalg.norm(x)

def random_SSS(x0=[0], steps=10):
    """
    Perform the Simple Slice Sacpler algorithm w.r.t. to the density pi
    given number of steps starting from x0.
    """
    for i in range(steps):
        t = np.random.uniform(0, pi(x0))
        x0 = runiform_ball(len(x0), -1 + np.sqrt(1 - 2*np.log(t)))
    return x0

def random_two_segments(left_border, right_border, shift=np.pi):
    """
    Sample from a uniform distribution on a union of two swgments:
    [left_border, right_border] and [left_border + shift, right_border + shift]
    """
    if left_border > right_border:
        sys.exit("ERROR in random_two_segments: left_border must be smaller than right_border")
    x = np.random.uniform(left_border, right_border)
    return x + shift if np.random.binomial(1, 0.5) == 1 else x

def ellipse_point(x1, x2, angle):
    """Return a point on the ellipse generated by x1 and x2 with the angle a."""
    if not len(x1) == len(x2):
        sys.exit("ERROR in ellipse_point: lengths of x1 and x2 must be equal")
    return(x1 * np.cos(a) + x2 * np.sin(angle))

def random_ESS(x0=[0], steps=10):
    """
    Perform the Elliptical Slice Sacpler algorithm w.r.t. to the density pi
    given number of steps starting from x0.
    """
    for i in range(steps):
        norm_x0 = np.linalg.norm(x0)
        t = np.random.uniform(0, np.exp(-norm_x0))
        w = np.random.normal(size=len(x0))
        norm_w = np.linalg.norm(w)

        Ax = norm_x0**2 - norm_w**2
        Bx = 2 * np.sum(x0 * w)
        Cx = 2 * np.log(t)**2 - norm_x0**2 - norm_w**2

        phi = np.sign(Bx) * np.arccos(Ax / np.sqrt(Ax**2 + Bx**2))
        psi = np.arccos(min(1, Cx / np.sqrt(Ax**2 + Bx**2)))

        theta = random_two_segments((phi + psi) / 2, np.pi + (phi - psi) / 2)

        x0 = ellipse_point(x0, w, theta)
    return x0

def rho(x):
    """Basically normalized pi for d = 1."""
    return (np.exp(-abs(x) - 0.5 * x**2)) / 1.31136

def draw_histogram_check(samples, bins = 50, range = [-3, 3]):
    """Draw histogramm with rho over it."""
    count, bins, ignored = plt.hist(samples,
                                    bins = bins, density = True, range = range)
    plt.plot(bins, rho(bins), color = 'r')
    plt.show()

def sample_and_draw_path(algorithm, x0, steps):
    """
    Simulate the algorithm given number of steps starting from x0 and
    draw the path of the first coordinate.
    """
    path = np.zeros((steps,))
    path[0] = x0[0]
    for i in range(1, steps):
        x0 = algorithm(x0, 1)
        path[i] = x0[0]
    plt.plot(range(steps), path)
    plt.show()


# %% set initial parameters
x0 = np.zeros((1000,))
N = 10**3

# %% test SSS. Calculate
start = time.time()
test_SSS = np.array([random_SSS(x0, steps = 1000) for i in range(N)])
print("CPU time:", time.time() - start)
print(f"CPU time: {time.time() - start}")
# %% test ESS. Calculate
start = time.time()
test_ESS = np.array([random_ESS(x0, steps = 1000) for i in range(N)])
print("CPU time:", time.time() - start)

# %% test MH. Calculate
start = time.time()
test_MH = np.array([random_MH(x0, steps = 1000) for i in range(N)])
print("CPU time:", time.time() - start)

# %% save the kernel state
dill.dump_session("ess_vs_ess_kernel.db")

# %% load the kernel state if needed
import dill
dill.load_session("ess_vs_ess_kernel.db")

# %%
def fun(p1, p2, p3, p4, p5, o1, o2, o3, o4, o5):
    return sum(p1, p2, p3, p4, p5, o1)

def fun2(*summands):
    return sum(*summands)

values = [1,2,3,4,45,6]
print(fun2(*values))
print(fun2(*1, 2))

updates = [specific_update, other_update]
all_update_functions = {'random': specific_update, 'other': other_update}
random_MH([0], 10, update=all_update_functions['random'])

results = [random_MH([0], 10, update) for update in updates]

start_vectors = [[0], [1], [1], [2]]
steps_list = [10, 10, 100, 10]

results = [random_MH(start_vectors[i], steps_list[i]) for i in range(len(start_vectors))]

# %% test all algorithms. Plot on one histogram
values = [test_SSS[:, 0], test_ESS[:, 0], test_MH[:, 0]]
count, bins, ignored = plt.hist(values, bins=50, density=True)
plt.plot(bins, rho(bins), color='r')
plt.show()

# %% test all
draw_histogram_check(test_SSS[:, 0])
draw_histogram_check(test_ESS[:, 0])
draw_histogram_check(test_MH [:, 0])


# %% draw paths
sample_and_draw_path(random_SSS, x0, 10**3)
sample_and_draw_path(random_ESS, x0, 10**3)
sample_and_draw_path(random_MH,  x0, 10**3)
